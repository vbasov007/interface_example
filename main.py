from some_module import SomeInterface, ConcreteImplementation


def do_something(calc_and_print: SomeInterface, q, w, e):
    # Эта функция ничего не знает про ConcreteImplementation, она работает только с интерфейсом. Ей можно передать любой
    # объект класса унаследованного от SomeInterface. Если у тебя по какой-то причине нужно поменять
    # ConcreteImplementation, например, в твоем случае, сделать все на pandas, то вместо SQL, то ты просто пишешь новый
    # класс наследуя его от SomeInterface и подставляешь объект этого нового класса при вызове этой функции. Таким
    # образом ты подучаешь независимость твоего алгоритма от низкоуровневых деталей реализации. В программировании
    # всегда надо стараться, чтобы высокоуровневые функции не зависели от реализации низкоуровневых. Т.е. например,
    # твой алгоритм не должен ничего знать о SQL. Вместо этого он должен обращаться и зависеть только от
    # абстрактного интерфейса. Абстрактный это означает не зависящий от реализации. Абстрактны SomeInterface ничего
    # не делает, там все функции пустые, он только задает набор функций и их параметры.

    calc_and_print.func1(q, w, e)
    calc_and_print.func2(q, e)


def main():
    # здесь создается объект в котором реализован конкретный способ
    c_and_p = ConcreteImplementation()
    do_something(c_and_p, 1, 2, 3)


if __name__ == '__main__':
    main()
